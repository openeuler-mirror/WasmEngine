From ed978016ca2d2619e5473cf998515e606d1324d8 Mon Sep 17 00:00:00 2001
From: meilier <xingweizheng@huawei.com>
Date: Fri, 5 Aug 2022 15:05:42 +0800
Subject: [PATCH 1/6] remove unused code and comments

---
 src/function_store/module_store.rs | 17 +----------------
 src/main.rs                        | 14 --------------
 src/wrapper/environment.rs         |  7 ++-----
 3 files changed, 3 insertions(+), 35 deletions(-)

diff --git a/src/function_store/module_store.rs b/src/function_store/module_store.rs
index cac3027..12616a6 100644
--- a/src/function_store/module_store.rs
+++ b/src/function_store/module_store.rs
@@ -1,8 +1,3 @@
-/*!
-Registries allow you to define "well-known" modules in the &environment that can be looked up by
-name and version.
-*/
-
 use anyhow::{anyhow, Result};
 use std::{collections::HashMap, sync::Arc, sync::RwLock};
 use tracing::info;
@@ -24,10 +19,7 @@ impl ModuleStore {
         }
     }
 
-    /// Insert module into the registry under a specific name, version and wasi capabilites.
-    ///
-    /// The version needs to be a correct semver string (e.g "1.2.3-alpha3") or the insertion will
-    /// fail. If the exact same version and name exists it will be overwritten.
+    /// Insert module into the ModuleStore under a specific name, module and wasi capabilites.
     pub fn insert(&self, name: &str, module: Module, wasi_cap: bool) -> Result<()> {
         let mut writer = self.module_store.write().unwrap();
 
@@ -44,9 +36,6 @@ impl ModuleStore {
         Ok(())
     }
 
-    /// Remove module under name & version from registry
-    ///
-    /// Exact version matching is used for lookup.
     pub fn remove(&self, name: &str) -> Result<()> {
         let mut writer = self.module_store.write().unwrap();
 
@@ -113,8 +102,4 @@ impl ModuleEntry {
     pub fn capability(&self) -> bool {
         self.wasi_cap
     }
-
-    fn all(&self) -> ModuleEntry {
-        self.clone()
-    }
 }
diff --git a/src/main.rs b/src/main.rs
index c4e7ec0..450910d 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,5 +1,4 @@
 use anyhow::Context;
-use clap::Parser;
 use serde::Deserialize;
 use std::{collections::HashMap, error::Error};
 use tracing::{info, instrument, Level};
@@ -23,22 +22,9 @@ lazy_static::lazy_static! {
     ]);
 }
 
-#[derive(Parser, Debug)]
-#[clap(about, version, author)]
-struct Args {
-    /// Log level used in wasm-engine, TRACE: 0, DEBUG: 1, INFO: 2(Default), WARN: 3, ERROR: 4
-    #[clap(short, long, default_value = "2")]
-    log_level: u8,
-
-    /// dir that contains preload apps
-    #[clap(short, long)]
-    preload_apps: Option<String>,
-}
-
 #[instrument]
 #[tokio::main]
 async fn main() -> Result<(), Box<dyn Error + Send + Sync + 'static>> {
-    let args = Args::parse();
     tracing_subscriber::fmt()
         .with_env_filter(EnvFilter::from_default_env())
         .try_init()?;
diff --git a/src/wrapper/environment.rs b/src/wrapper/environment.rs
index b7ea873..bb9bde7 100644
--- a/src/wrapper/environment.rs
+++ b/src/wrapper/environment.rs
@@ -12,10 +12,7 @@ pub const UNIT_OF_COMPUTE_IN_INSTRUCTIONS: u64 = 100_000;
 /// Environments let us set limits on instances:
 /// * Memory limits
 /// * Compute limits
-/// * Access to host functions
-///
-/// They also define the set of plugins. Plugins can be used to modify loaded Wasm modules.
-/// Plugins are WIP and not well documented.
+/// * Access to modules
 #[derive(Clone)]
 pub struct Environment {
     runtime: WasmtimeRuntime,
@@ -36,7 +33,7 @@ impl Environment {
         &self.runtime
     }
 
-    pub fn registry(&self) -> &ModuleStore {
+    pub fn store(&self) -> &ModuleStore {
         &self.store
     }
 }
-- 
2.27.0

